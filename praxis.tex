%%MAIN: thesis.tex

%%%%% The Validation %%%%%
\chapter{Implementation: Lesson Plans} \label{ch_teaching}

In its current form, the ``Processing Abstractions'' environment as presented in chapter \ref{ch_pa} is mainly targetted at the obligatory introduction to computer sciences at high school level.

Before going into empirical results from using this environment in two courses, three lesson plans will be presented for which it has been developed: a \emph{Sichtenwechsel} in computer architecture (section \ref{sc_lesson_ca}); an introduction into the inner workings of a compiler (section \ref{sc_lesson_compiler}); and first a plan for a general introduction to programming (section \ref{sc_lesson_intro}). Some ideas for how to expand it for other school levels will be presented in section \ref{sc_lesson_other}.

For all the lessons, students will need a local environment of ``Processing Abstractions'' installed on a computer available to them. See appendix \ref{app_setup} for how to set it up. Additionally, for non-German speaking students the contents will have to be translated to the teaching language.



\section{Introduction to Programming} \label{sc_lesson_intro}

While the ``Processing Abstractions'' environment has been developed for linking programming and computer architecture, it can also be used for an introduction to programming. This does even help linking programming and computer architecture for students, since they can start at the same point and reuse the experience already gained.


\subsection{Educational objective}

After the introduction, students should ...
\begin{itemize}
\item be able to write programs matching given visual outputs.
\item be able to read and understan programs with a limited command set.
\item be able to learn from their mistakes, correct themselves and not be afraid of breaking things.
\item have a solid foundation for taking on the task of writing a basic but still interesting app or game.
\end{itemize}


\subsection{Prerequisites}

Students need experience in using their own computer, including ...
\begin{itemize}
\item downloading and extracting archives
\item dealing with their virus scanner\footnote{At least under Windows, many scanners flag GT as untrustworthy due to its executable lacking a valid signature. Some virus scanners even block the entire download, if the archive is distributed over a network.}
\end{itemize}

Additionally, the teacher must prepare their contents in GT e.\,g. as described in \ref{app_setup} and distribute them. Ensure that the first lesson page will be displayed on first startup.


\subsection{Introduction to Glamorous Toolkit} \label{ssc_lesson_gt}

Since Glamorous Toolkit will be a new environment altogether for all students, some basics on its usage have to be introduced first within ten minutes:

\begin{instructions}
\item Ask students to download and extract your GT distribution as homework for the first lesson. Under Windows, they might run into a first issue with their virus scanner blocking the download, so remind them about what to do in that case.\footnote{In most virus scanner settings, the warning can be overruled by the user; else they might have to \emph{temporarily} disable scanning for this one download.}
\item Tell students to start GT and open the notebook page about working with Glamorous Toolkit (``Arbeiten mit Glamorous Toolkit'' in the included teaching materials). Also ask them to help their neighbours, if they see them struggling. Use the time while students are reading and doing the first tasks for ensuring that everyone has managed to get GT running.
\item Introduce GT as an interactive notebook similar to what students already know from class.\footnote{Many schools have standardized on working with the Microsoft 365 Office Suite which includes OneNote.} One main difference will be that additional views will open to the side, hiding the table of contents. So show them, how to get back by selecting the left-most view (through the blue dots at the center top) and expand it (through the $+$ at the top left).
\item If you want students to be able to take notes of their own inside GT notebooks, show them how to move a page to their local knowledge base (where it can be backed up individually) and how to create and structure new paragraphs (\ct{Ctrl+Enter}, \ct{Alt+Shift+Arrow}). Markdown syntax for formatting does not have to be introduced explicitly, that can be replicated by students by inspecting your content.
\item Finally, keep in mind GT's ability to be inspected at every level and point more advanced students towards using these (e.\,g. by \ct{Ctrl+Shift+Alt+Click} anywhere, by double-clicking on list items, or by going through the different views of an object).
\end{instructions}

Please note that as described in \ref{sc_gt}, GT is bleeding edge technology and might not always behave the way you and your students have become used to: Since notebook pages are rendered progressively, scrolling won't always work smoothly (and will scroll inner content, if the mouse cursor isn't positioned at a page's border); occasionally unexpected error messages trigger the debugger to pop up which has to be closed again; and sometimes the keyboard modifiers may get stuck, resulting in shortcuts no longer working (which is resolved by switching to a different app and back).



\subsection{Lesson Plans}

\begin{todo}
\item stepwise introduction to Processing (introduced in \ref{sc_processing})
\item imperative, few commands: \texttt{size}, \texttt{rect}, \texttt{ellipse}, \texttt{fill}
\item teaches importance of order
\item tasks: produce given output
\item debugging consists in modifying values (result is immediately visible)
\item quicker and more proficient students can easily skip ahead (loops, animations, recursion)
\item introduce variables, loops, animation, interaction
\item available tools: output, step-by-step debugger (for now, more later)
\end{todo}



\section{Lesson on Computer Architecture} \label{sc_lesson_ca}
% Using PA to demonstrate what happens under the hood when running a program in a high level language.
Introductions to computer science which extend beyond a pure programming course often contain lessons on computer architecture. E.\,g. the curriculum \cite[p.\,145]{Erz16} asks for students to ``know how computers and networks are structured and work''.

Now a sequence of lessons on the subject might be ordered either bottom up (as elaborated in subsection \ref{ssc_bottom_up}) or top down (\ref{ssc_top_down}). In either case, this proposed lesson will go towards the middle or can be used at the end as part of a repetition sequence.

Part of this has been validated (cf. \ref{sc_validation_ca})


\subsection{Educational objective}

\begin{todo}
\item students can explain how a program might actually be run on hardware
\end{todo}


\subsection{Prerequisites}
Students must already know basic programming skills in a high level language such as Processing (see section \ref{sc_processing}). In particular, they must know about variables and loops. An introduction to programming could also be done using \texttt{PA} as outlined in \ref{sc_lesson_intro} above.

The more students are supposed to work on their own, the more they'll need an overview over the different layers prior to combining them. As a prerequisite, it it recommended to at least introduce the Von Neumann architecture and its split of the CPU into control unit and arithmetic unit (see figure \ref{fig_von_neumann}).

\begin{cfigure}[fig_von_neumann]{Von Neumann architecture.}
\includegraphics[width=10cm]{Von_Neumann_Architecture}
\begin{todo}
\item replace or properly attribute: Kapooht, 2013, CC BY-SA 3.0
\end{todo}
\end{cfigure}

In a bottom up approach, this might also include the introduction of transistors, logic gates and circuits. In a top down approach, these could also be treated afterwards.


\subsection{Lesson Plan}

The goal of the lesson is for students to have connected their knowledge of high level programming with what happens within their machine when a program is executed.

If this is the student's encounter with Glamorous Toolkit, at least a brief introduction is in order (see \ref{ssc_lesson_gt}). Else we can directly start with a reminder of what they already know about programming.




\section{Lesson on Compilers} \label{sc_lesson_compiler}

Using PA to demonstrated the steps of lexing, parsing, transpiling, compiling and optimizing.

Part of this has been validated (cf. \ref{sc_validation_compiler})


\subsection{Educational objective}

\begin{todo}
\item students can explain the difference between high and low level language
\item students can enumerate the steps required for compiling a program
\item students have an understanding of the roles a lexer, parser, transpiler and compiler play
\end{todo}


\subsection{Prerequisites}

\begin{todo}
\item programming with Processing (e.\,g. from \ref{sc_lesson_intro})
\item GT/PA installed (e.\,g. from \ref{ssc_lesson_gt})
\item Stacks and registers
\end{todo}


\subsection{Lesson Plan}

\begin{todo}
\item Repetition high level programming (see tasks in PA)
\item Comparision with low level programming (e.\,g. \cite{Tom15}): levels 1 to 6 (introduces jumps, memory access, arithmetic)
\item Presenting/reading overview, compare with natural language
\item Lexer: compare given example with mainly different whitespace; what are tokens?
\item Parser: describe AST in own words, compare with sentence structure from natural languages; develop simple parsing model (better views?)
\item Transpiler (optional): compare Processing and Smalltalk
\item Compiler: compare AST with intermediary representation; compare Program with intermediary representation; compare intermediary representation with \cite{Tom15}
\item Optimization: naive examples
\end{todo}



\section{Further Lesson Ideas} \label{sc_lesson_other}

Connecting PA with Smalltalk; extend it to object oriented programming; mould the environment to questions developed during the course; ...
