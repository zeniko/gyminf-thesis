%%%%% Technical Details %%%%%

\chapter{Installing and Using ``Processing Abstractions''} \label{app_setup}

In order to set up Processing Abstractions, first download \ac{GT} from \url{https://gtoolkit.com/download/} for your platform and extract the archive's entire content.

Before running it, create a new text file called \ct{startup.st} in \ac{GT}'s top-level folder besides \ct{GlamorousToolkit.image} with the following content (access it through figure \ref{fig_startup_st_qr}):

\begin{code}
Metacello new
	repository: 'github://zeniko/\ac{GT}-exploration:thesis/src';
	baseline: 'GtExploration';
	load.
Metacello new
	repository: 'github://zeniko/processing-abstractions:thesis/src';
	baseline: 'ProcessingAbstractions';
	load.

"Hide the 'Implementation and Tests' section."
GtExplorationHomeSection studentMode: true.

"Make indenting keyboard shortcuts available to non-US-English keyboard layouts
(cf. https://github.com/feenkcom/gtoolkit/issues/3002)."
LeSnippetElement keyboardShortcuts
	at: #IndentSnippet
		put: BlKeyCombinationBuilder new alt shift arrowRight build;
	at: #UnindentSnippet
		put: BlKeyCombinationBuilder new alt shift arrowLeft build.

"Make the zoom in keyboard shortcut available to de-CH keyboard layouts
(cf. https://github.com/feenkcom/gtoolkit/issues/4624)."
TLeWithFontSize compile:
	((TLeWithFontSize methodNamed: #initializeFontSizeShortcuts) sourceCode
		copyReplaceAll: 'equal' with: 'shift minus').

"Patch unneeded addressbar out of YouTube snippet
(cf. https://github.com/feenkcom/gtoolkit/issues/4560)."
LeYoutubeReferenceElement compile:
	((LeYoutubeReferenceElement methodNamed: #updatePicture) sourceCode
		copyReplaceAll: '</iframe>'' ' with: '</iframe>''; removeChildAt: 1 ').
\end{code}

Finally, run the \ct{GlamorousToolkit} executable (under Windows and Linux it is located in the \ct{bin} subfolder). The teaching materials of Processing Abstractions are now available behind the ``Unterrichtseinheiten'' home tile.

Verify that everything works as desired, and then close and save the changes to the image.

\emph{Warning:} If you have already used \ac{GT} before, the contents of your local knowledge database will also be included in \ac{GT}'s image. Therefore, rename that folder (usually \ct{lepiter/default} in your documents folder) before starting the \ac{GT} meant for distribution, and undo the renaming before starting your own \ac{GT} instance again.

Also, since the executable \ct{GlamorousToolkit.exe} is located in a subdirectory under Windows and Linux, adding a top-level link can help students. See \url{https://github.com/zeniko/gtRunner} for a ready-to-use drop-in.

\begin{cfigure}[fig_startup_st_qr]{QR-link to the code for \ct{startup.st}, for convenience}
\href{https://github.com/zeniko/gyminf-thesis/blob/main/appendix.tex}{\includegraphics[height=2.5cm]{startup.st}}
\end{cfigure}



\chapter{GT Processing API} \label{app_api}

This appendix lists the available \ac{API} calls implemented in Processing Abstraction's partial implementation of Processing.\footnote{For comparison, the full \ac{API} or Processing's Python mode is available at \archivedurl{https://py.processing.org/reference/}.} This has been autogenerated from the \ac{GT} page ``Processing API'':

\input{appendix-api}



\chapter{Views} \label{app_views}

The following pages show screenshots of all the views available through \ct{ProcessingProgram}. Multiple views are combined in single screenshots. This is not only for compactness, but also the way most views are meant to be used: for comparing various aspects of the same program. Combined views are usually linked, so that interacting with one view also affects the linked view(s).

To access the code implementing a view, \ct{Alt}+click on its tab. This will also show the view's internal name. Alternatively, all views of \ct{ProcessingProgram} are also listed in \ref{app_view_names}.

\begin{cfigure}[fig_view_abstractions]{The Abstractions view with source code, \ac{AST}, bytecode, and output showing (this is the default view for \ct{ProcessingSource} and \ct{ProcessingProgram}, as it encapsulates the essence of Processing Abstractions)}
\includegraphics[width=.7\textwidth]{view_abstractions}
\end{cfigure}

\begin{cfigure}[fig_view_chars_bytes]{The Characters and Bytes views are for discussing encodings (bytes are UTF-8 encoded)}
\includegraphics[width=.7\textwidth]{view_chars_bytes}
\end{cfigure}

\begin{cfigure}[fig_view_tokens_ast]{The Tokens and \ac{AST} views are for discussing lexer and parser}
\includegraphics[width=.7\textwidth]{view_tokens_ast}
\end{cfigure}

\begin{cfigure}[fig_view_ast_tree]{The \ac{AST} as a pannable and zoomable tree, emphasizing the \ac{AST}'s tree form}
\includegraphics[width=.7\textwidth]{view_ast_tree}
\end{cfigure}

\begin{cfigure}[fig_view_transpilation]{The Transpilation view, showing Processing and Smalltalk code side by side, is for comparing two different programming languages}
\includegraphics[width=.7\textwidth]{view_transpilation}
\end{cfigure}

\begin{cfigure}[fig_view_prefix_postfix]{Source code, \ac{AST}, and a transpilation to two pseudolanguages with pure prefix and postfix notation, respectively, for discussing programming language syntax}
\includegraphics[width=.7\textwidth]{view_prefix_postfix}
\end{cfigure}

\begin{cfigure}[fig_view_ir_bytecode]{The \ac{IR} and Bytecode views show to lower-level representations of the code}
\includegraphics[width=.7\textwidth]{view_ir_bytecode}
\end{cfigure}

\begin{cfigure}[fig_view_hexdump]{The Hexdump view serializes every method into its individual bytes}
\includegraphics[width=.7\textwidth]{view_hexdump}
\end{cfigure}

\begin{cfigure}[fig_view_runsteps]{The Runsteps view is for stepping through execution and inspect variables and stack values}
\includegraphics[width=.7\textwidth]{view_runsteps}
\end{cfigure}

\begin{cfigure}[fig_view_slices]{The Slices view shows the list of objects linking Processing and Smalltalk code (see figure \ref{fig_view_transpilation} above)}
\includegraphics[width=.7\textwidth]{view_slices}
\end{cfigure}

\begin{cfigure}[fig_view_shapes]{The Shapes view displays all output shapes individually}
\includegraphics[width=.7\textwidth]{view_shapes}
\end{cfigure}

\begin{cfigure}[fig_view_raw]{The Raw view is provided by \ac{GT} and shows all variables of an instantiated object}
\includegraphics[width=.7\textwidth]{view_raw}
\end{cfigure}

\begin{cfigure}[fig_view_meta]{The Meta view is provided by \ac{GT} and shows all methods defined for the instantiated object}
\includegraphics[width=.7\textwidth]{view_meta}
\end{cfigure}



\chapter{Technical Implementation of ``Processing Abstractions''} \label{app_implementation}


\section{Repositories}

The contents of Processing Abstractions are distributed over two GitHub repositories:

The repository \ct{zeniko/gt-exploration}\footnote{\emph{Cf.} \url{https://github.com/zeniko/gt-exploration/tree/thesis}.} contains the source code for the Processing compiler, for the runtime support, and for all the views. In addition, it also contains two dozen Processing programs as examples and test cases (in \ct{ProcessingSourceExamples}), demonstrating the entire range of implemented features. Furthermore, this repository contains process documentation in a \ac{GT} notebook named ``Implementation and Tests'' on \ac{GT}'s home screen and for that also prototype implementations of the other approaches mentioned in \ref{ssc_other_approaches}.

The repository \ct{zeniko/processing-abstractions}\footnote{\emph{Cf.} \url{https://github.com/zeniko/processing-abstractions/tree/thesis}.} mainly contains teaching material for the sequences proposed in chapter \ref{ch_teaching} in a \ac{GT} notebook named ``Unterrichtseinheiten''. In contrast to the source code repository, this content is written in German, as that was the teaching language for the validation rounds in chapter \ref{ch_practice}. Programs for examples and tasks are contained in \ct{ProcessingAbstractionsExamples} and sketches in \ct{ProcessingAbstractionSceneries}.

Both repositories have a \ct{thesis} branch that has been frozen to the state described in this thesis, whereas development will continue on the \ct{main} branches.



\section{Processing/Python Snippet} \label{app_snippet}

The Processing/Python snippet implements a model-view-viewmodel pattern. The implementation seen in figure \ref{fig_uml_snippet} mostly inherits from \ac{GT}'s Python snippet just includes minor changes to the \acs{UI} such as showing ``Processing'' in the upper right corner instead of information about a connected Python instance.

The main difference to the Python snippet is in the \ct{GtProcessingCoderModel}, which offers more different execution modes for Processing code:

\begin{itemize}
\item {\small\faPlay} calls \ct{GtProcessingCoderModel>>doIt:} to create a \ct{ProcessingSource} and show its Output view. This action's shortcut is handled by \ct{GtProcessingCoderRunShortcut}.
\item {\small\faPlay}\texttt{i} calls \ct{GtProcessingCoderModel>>doItAndGoSerialized:} to create a \ct{ProcessingProgram}, extract its runsteps, and show a \ct{Stepper} showing the \ct{gtOverviewFor:} view of \ct{ProcessingRunStep} (this is a slightly reduced variant of \ct{gtAbstractionsFor}, for manageability reasons). This action's shortcut is handled by \ct{GtProcessingCoderRunStepsShortcut}.
\item {\small\faPlay}\texttt{a} calls \ct{GtProcessingCoderModel>>doItAndGo:} to create a \ct{ProcessingProgram} and show its Abstractions view. This action's shortcut is handled by \ct{GtProcessingCoderRunDetailsShortcut}.
\item \lightning\ calls \ct{GtProcessingCoderModel>>doItAndGoAsynchronous:} to create a \ct{ProcessingProgram} and call its \ct{debug} method to start a debugging session in \ac{GT}'s debugger. This action's shortcut is handled by \ct{GtProcessingCoderDebugShortcut}.
\end{itemize}

\begin{cfigure}[fig_uml_snippet]{Diagram of classes involved in \ct{LeProcessingSnippet}}
\input{diagrams/uml-snippet}
\end{cfigure}



\section{Views} \label{app_view_names}

The following views are available as arguments for \ct{ProcessingSource>>renderLiveView:} (see page \pageref{code_embedding_view}). Figure \ref{fig_uml_views} shows an overview of all view implementors.

\begin{cfigure}[fig_uml_views]{Diagram of all views provided and their implementors (methods set in \textit{italics} are forwarded to the actual implementor)}
\input{diagrams/uml-views}
\end{cfigure}

\begin{description}
\item[\texttt{gtAbstractionsFor:}] \hfill \\
	(implemented by \ct{ProcessingProgram}) combines \ct{gtSourceCodeFor:}, \ct{gtTreeFor:}, \ct{gtBytecodeFor:}, and \ct{gtOutputFor:}, linking the source to the other three views through a common \ct{Announcer} reacting to selection changes (shown in figure \ref{fig_view_abstractions}).
\item[\texttt{gtBytecodeFor:}] \hfill \\
	uses the \ct{CompiledMethod} instances of each method in a compiled class' \ct{class methodDict} to access its \ct{symbolicBytecodes} and show the resulting \ct{SymbolicBytecode}s' bytes and mnemonic (shown on the right in figure \ref{fig_view_ir_bytecode}). \ct{gtBytecodePlusSourceFor:} combines this view with \ct{gtSourceCodeFor:}.
\item[\texttt{gtBytecodePlusIRFor:}] \hfill \\
	combines the \ct{gtBytecodeFor:} with \ct{gtIntermediaryRepresentationFor:} (shown in figure \ref{fig_view_ir_bytecode}).
\item[\texttt{gtHexDumpFor:}] \hfill \\
	shows individual bytes for all compiled methods.
\item[\texttt{gtIntermediaryRepresentationFor:}] \hfill \\
	uses the \ct{OpalCompiler} to translate the transpiled Smalltalk code to \ct{IRInstruction}s (shown on the left in figure \ref{fig_view_ir_bytecode}). \ct{gtIntermediaryRepresentationPlusSourceFor:} combines this view with \ct{gtSourceCodeFor:}.
\item[\texttt{gtOutputFor:}] \hfill \\
	displays a newly created \ct{ProcessingCanvasElement} with attached event listeners for interactivity (shown on the bottom right in figure \ref{fig_view_abstractions}). \ct{gtOutputPlusSourceFor:} combines this view with \ct{gtSourceCodeFor:}.
\item[\texttt{gtOutputShapesFor:}] \hfill \\
	shows a list of all \ct{ProcessingCanvasShape}s in the order they were drawn (shown in figure \ref{fig_view_shapes}). Clearing the canvas with \ct{background(...)} also clears this list.
\item[\texttt{gtSlicesFor:}] \hfill \\
	shows a list of \ct{ProcessingTranspilationSlice}s with the corresponding expressions in Processing source code and Smalltalk transpilation highlighted (shown in figure \ref{fig_view_slices}).
\item[\texttt{gtSourceBytesFor:}] \hfill \\
	shows a list of \ct{SmallInteger}s corresponding to the bytes of the source code after UTF-8 encoding (shown on the right in figure \ref{fig_view_chars_bytes}) \ct{gtSourceBytesPlusSourceFor:} combines this view with \ct{gtSourceCodeFor:}.
\item[\texttt{gtSourceBytesPlusCharsFor:}] \hfill \\
	combines \ct{gtSourceCharsFor:} and \ct{gtSourceBytesFor:} (shown in figure \ref{fig_view_chars_bytes}).
\item[\texttt{gtSourceCharsFor:}] \hfill \\
	shows a list of \ct{Character}s corresponding to each of the Processing source code's characters (shown on the left in figure \ref{fig_view_chars_bytes}). \ct{gtSourceCharsPlusSourceFor:} combines this view with \ct{gtSourceCodeFor:}.
\item[\texttt{gtSourceCodeFor:}] \hfill \\
	displays a fresh read-only editor instance from \ct{SmaCCParseNode>>gtSourceEditorWithHightlight:} with a custom \ct{BrTextEditorReadonlyWithNavigationMode} mode (shown on the top left in figure \ref{fig_view_abstractions}, on the left in \ref{fig_view_transpilation}, \etc).
\item[\texttt{gtStepsFor:}] \hfill \\
	shows a list of \ct{ProcessingRunStep}s and their own \ct{gtAbstractionFor:} view, consisting of their \ct{gtSourceCodeFor:}, \ct{gtBytecodeFor:}, \ct{gtVariablesFor:}, \ct{gtStackFor:}, and \ct{gtOutputFor:} (shown in figure \ref{fig_view_runsteps}). \ct{ProcessingRunStep>>gtOverviewFor:} is a simplified variant of this shown from the Processing/Python snippet.
\item[\texttt{gtTokensFor:}] \hfill \\
	shows a list of \ct{SmaCCToken}s that were produced by \ct{ProcessingParser} (shown on the left in figure \ref{fig_view_tokens_ast}). \ct{gtTokensPlusSourceFor:} combines this view with \ct{gtSourceCodeFor:}.
\item[\texttt{gtTokensPlusTreeFor:}] \hfill \\
	combines \ct{gtTokensFor:} with \ct{gtTreeFor:} (shown in figure \ref{fig_view_tokens_ast}).
\item[\texttt{gtTranspilationFor:}] \hfill \\
	shows the transpiled Smalltalk code in \ct{GT}'s code viewer, which separates methods and adds syntax highlighting. \ct{gtTranspilationPlusSourceFor:} combines this view with \ct{gtSourceCodeFor:} (shown in figure \ref{fig_view_transpilation}).
\item[\texttt{gtTranspilationPostfixFor:} and \texttt{gtTranspilationPrefixFor:}] \hfill \\
	show a \ct{String} produced by \ct{ProcessingTranspilerVariant} in either its \ct{prefix} or \ct{postfix} modes (both shown at the bottom in figure \ref{fig_view_prefix_postfix}).
\item[\texttt{gtTreeFor:}] \hfill \\
	shows a treelist of \ct{PyRootNode}s for expression roots and \ct{SmaCCToken}s for structural tokens (shown on the right in figure \ref{fig_view_tokens_ast}).
\item[\texttt{gtTreeMondrianFor:}] \hfill \\
	shows a horizontal \ct{GtMondrian} tree produced by \ct{ProcessingTreeMondrianCreator} (shown in figure \ref{fig_view_ast_tree}). \ct{gtTreePlusSourceFor:} combines this view with \ct{gtSourceCodeFor:}.
\end{description}



\chapter{Questionnaires} \label{app_questionnaires}

The following questionnaires are a reproduction of the originals, which were implemented in \href{https://forms.office.com/}{Microsoft Forms}, and are in German, since that's the students' teaching language.



\section{Questionnaire for \ref{sc_validation_ca}} \label{app_questionnaire_1}


\subsection*{Feedback zur heutigen Unterrichtssequenz}

\begin{Questionnaire}

\item \Question{Wie hat Ihnen die heutige Unterrichtssequenz gefallen?} \\ gar nicht \Qrating{5} sehr gut

\item \Question{Welche Themen haben Sie heute alle bearbeiten können?}
\begin{Qlist}
\item Arbeiten mit Glamorous Toolkit
\item Maschinensprache und Prozessor
\item Funktionen eines Compilers
\item Anhang
\end{Qlist}

\item \Question{Wie sehr trauen Sie sich zu, die heutigen Inhalte jemand anderem zu erklären?} \\ gar nicht \Qrating{5} \emph{easy-peasy}

\item \Question{Wie viele der Python-Progrämmchen haben Sie selbst verändert?}
\begin{Qlist}[$\ocircle$]
\item Keines
\item Eines
\item Zwei bis drei
\item Vier oder mehr
\end{Qlist}

\item \Question{Was ist ein Stack?} \Qlines{1}

\item \Question{Was machen Lexer und Parser?} \Qlines{1}

\item \Question{Wie gut hat die Lernumgebung für Sie funktioniert?} \\ gar nicht \Qrating{5} problemlos

\item \Question{Was hat Ihnen an der Lernumgebung gefallen?} \Qlines{2}

\item \Question{Welche Änderungen an der Lernumgebung wünschen Sie sich für die nächste Klasse?} \Qlines{2}

\item \Question{Wie hilfreich fanden Sie die Nebeneinanderstellungen der unterschiedlichen Schritte beim Ausführen/Übersetzen eines Programms?} \\ weglassen \Qrating{5} bitte mehr davon

\item \Question{Beschreiben Sie in eigenen Worten: Wie wird ein Programm auf einem Prozessor ausgeführt?} \Qlines{2}

\item \Question{Beschreiben Sie in eigenen Worten: Wie wird ein Programm in einer Hochsprache wie Processing für den Prozessor aufbereitet?} \Qlines{2}

\item \Question{Was hatte das heutige Thema mit Silizium, Transistoren, Gattern und Schaltungen zu tun?} \Qlines{2}

\suspend{Questionnaire}


\subsection*{Feedback zum Informatikunterricht der letzten zwei Jahre}

\resume{Questionnaire}

\item \Question{Was war für Sie das Highlight vom Informatik-Unterricht? (Was hat Ihnen am meisten Eindruck gemacht?)} \Qlines{1}

\item \Question{Was ist Ihnen vom Informatik-Unterricht alles geblieben (einige Stichworte zum Stoff)?} \Qlines{2}

\item \Question{Was hat Ihnen am Informatik-Unterricht gefallen?} \Qlines{2}

\item \Question{Wenn Sie mir vor zwei Jahren einen Hinweis geben könnten: Was hätten Sie sich für den Unterricht anders gewünscht?} \Qlines{2}

\end{Questionnaire}



\section{Questionnaire for \ref{sc_validation_compiler}} \label{app_questionnaire_2}


\subsection*{Feedback zur heutigen Unterrichtssequenz}

\begin{Questionnaire}

\item \Question{Wie hat Ihnen die heutige Unterrichtssequenz gefallen?} \\ gar nicht \Qrating{5} sehr gut

\item \Question{Welche Themen haben Sie heute alle bearbeiten können?}
\begin{Qlist}
\item Arbeiten mit Glamorous Toolkit
\item Human Resource Machine (aus Maschinensprache und Prozessor)
\item Lexer und Parser
\item Transpiler und Compiler
\item Optimierer
\end{Qlist}

\item \Question{Wie sehr trauen Sie sich zu, die heutigen Inhalte jemand anderem zu erklären?} \\ gar nicht \Qrating{5} \emph{easy-peasy}

\item \Question{Wie viele der Python-Progrämmchen haben Sie selbst verändert?}
\begin{Qlist}[$\ocircle$]
\item Keines
\item Eines
\item Zwei bis drei
\item Vier oder mehr
\end{Qlist}

\item \Question{Weshalb kann ein Prozessor ein Processing-Programm nicht ohne Übersetzung ausführen} \Qlines{1}

\item \Question{Was machen Lexer und Parser?} \Qlines{1}

\item \Question{Wie gut hat die Lernumgebung für Sie funktioniert?} \\ gar nicht \Qrating{5} problemlos

\item \Question{Was hat Ihnen an der Lernumgebung gefallen?} \Qlines{2}

\item \Question{Welche Änderungen an der Lernumgebung wünschen Sie sich für die nächste Klasse?} \Qlines{2}

\item \Question{Wie hilfreich fanden Sie die Nebeneinanderstellungen der unterschiedlichen Schritte beim Ausführen/Übersetzen eines Programms?} \\ weglassen \Qrating{5} bitte mehr davon

\item \Question{Beschreiben Sie in eigenen Worten: Wie wird ein Programm in einer Hochsprache wie Processing für den Prozessor aufbereitet?} \Qlines{2}

\item \Question{Was hatte das heutige Thema mit Codierung und was mit Programmieren zu tun?} \Qlines{2}

\suspend{Questionnaire}


\subsection*{Feedback zum Informatikunterricht}

\resume{Questionnaire}

\item \Question{Was war für Sie das Highlight vom Informatik-Unterricht? (Was hat Ihnen am meisten Eindruck gemacht?)} \Qlines{1}

\item \Question{Was ist Ihnen vom Informatik-Unterricht alles geblieben (einige Stichworte zum Stoff)?} \Qlines{2}

\item \Question{Was hat Ihnen am Informatik-Unterricht gefallen?} \Qlines{2}

\item \Question{Welche Änderungen wünschen Sie sich fürs kommende Schuljahr in Informatik?} \Qlines{2}

\end{Questionnaire}
