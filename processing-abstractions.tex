%%MAIN: thesis.tex

%%%%% The Solution %%%%%
\chapter{Proposed Solution: A New Teaching Environment} \label{ch_pa}
% formerly: \texttt{Processing Abstractions}

\section{Development of "Processing Abstractions"}
Excerpts from gt-exploration Lepiter pages

\begin{todo}
\item Adaptable foundation: GT
\item Student language: visual language, own language (e.\,g. like Grace \cite{Bla18}), common language?
\item Decision: Processing/Python (cf. \ref{sc_processing}) -- based on popular Python, visual primitives for quick results (which is motivating cf. \cite{Chi23})
\item API reference in appendix \ref{app_api}
\item setup instructions in appendix \ref{app_setup}
\item Critics from \cite{Chi23}: limited API (\ct{square}, \ct{circle} could be removed; see also \ref{ssc_manageability}), absolute coordinates initially more intuitive, Turtle and other approaches implementable through transparent functions or libraries
\item Various approaches to run Processing: PythonBridge, interpreter, compiler, transpiler
\item Class hierarchy
\end{todo}

\begin{todo}
\item Languages implemented within GT are inspectable and moldable as far as they're implemented: parser state, tokens, parse tree, bytecode, \emph{etc.}
\item Custom views are cheap to implement, given knowledge of Smalltalk+GT
\item Was very useful for quick prototyping, reusable code, ... (cf. chapter \ref{ch_pa})
\end{todo}


\section{Abstraction Levels}
For each a short problem description and a presentation of the chosen approach:

\subsection{Source Code}
\subsection{Abstract Syntax Tree}
\subsection{Transpilation/IR}
\subsection{Machine Code}
\subsection{Output}


\begin{code}
ProcessingCanvas >> ellipse: x y: y dx: dx dy: dy [
	self
		ellipse: dx
		by: dy
		at: x @ y
]
\end{code}


\begin{code}
ProcessingCanvas >> endFrame [
	presenter updateOutput.
	(1 / frameRate) seconds wait.	"The frame rate is adjustable through `frameRate()`"
	frameCount := frameCount + 1.
	transform := #yourself	"Transforms are reset at the end of a draw-cycle"
]
\end{code}
