%%MAIN: thesis.tex

%%%%% Background Information %%%%%
\chapter{Technical Background} \label{ch_background}

The product of this thesis is implemented in Glamorous Toolkit and bases teaching material on the ``Processing'' programming language. On overview of both is given in this chapter for readers unaware of either of them.


\section{Processing} \label{sc_processing}

``Processing'' is a programming language consisting of a graphics API built upon a mainstream language as a base. Development started between 1997 and 2004 at the MIT Media Lab with the goal of creating a language for teaching art students the fundamentals of programming as basis for creating digital, visual art.

Its authors, Reas and Fry \cite{Rea14}, wanted to create a unified teaching system consisting of art, language and a matching IDE. They based the language upon then popular and portable Java, removing much of the boilerplate required for object orientation, enhancing it with visual primitives and implicitly showing an output window, allowing for quick results (see figure \ref{fig_alpinerWanderweg}).

\begin{figure} \label{fig_alpinerWanderweg}
\centering
\begin{minipage}{.5\textwidth}
\begin{code}
// Output canvas dimensions
size(200, 200);
// (Default white) square
rect(50, 50, 100, 100);
// Red inner rectangle
fill(255, 0, 0);
rect(50, 50 + 100 / 3, 100, 100 / 3);
\end{code}
\end{minipage}
\begin{minipage}{.45\textwidth}
\centering
\includegraphics[height=3cm]{images/alpinerWanderweg}
\end{minipage}
\caption{Example code (with Java syntax) and output}
\end{figure}

As elaborated in \ref{ssc_top_down}, Processing was meant to be taught top down, starting from art and then decomposing it. As such, its main introduction features several chapters focused on exhibits of digital or hybrid art such as Manfred Mohr's \emph{Une esthétique programmée} or Steph Thirion's \emph{Eliss}.

Apart from graphical primitives (see appendix \ref{app_api} for a subset), Processing features an implicit event loop which allows for creating (interactive) animations within a dozen lines of code (see figure \ref{fig_jumpingBall}).

\begin{figure} \label{fig_jumpingBall}
\centering
\begin{minipage}{.5\textwidth}
\begin{code}
y = 50; dy = 0

# called once after global code
def setup():
    size(100, 200)

# called repeatedly for every frame
def draw():
    global y, dy
    background(192)
    circle(50, y, 50)
    y += dy; dy += 1
    if y > height - 25:
        dy = -0.9 * dy
\end{code}
\end{minipage}
\begin{minipage}{.45\textwidth}
\centering
\includegraphics[height=3cm]{images/ball1}
\includegraphics[height=3cm]{images/ball2}
\includegraphics[height=3cm]{images/ball3}
\includegraphics[height=3cm]{images/ball4}
\end{minipage}
\caption{Example code (with Python syntax) and one output frames}
\end{figure}

Reacting to input happens either by pulling state while painting a frame (implicit global variables \ct{mousePressed}, \emph{etc.}) or by defining event handlers alongside \ct{setup} and \ct{draw}.

Since Python has become the prevalent teaching language (\cite{Cod20}), Processing has been extended with a Python mode which leads to Processing code reading like Python code with the additional Processing API calls and exposes most of Python's libraries to Processing code. This allows using Processing as a starting language and later seamlessly transitioning to pure Python code, which remains part of the motivation for students: learning an ``actually useful'' language.

As the official Processing IDE continues to be written in Java, Processing's official Python mode uses Jython for compiling the code to Java Bytecode. Since developers have started moving away from Java, there are now several reimplementations of Processing such as p5.js for running Processing on top of JavaScript in a web environment, p5.py for running Processing in a pure Python environment\footnote{Requiring two additional lines: \ct{from p5 import *} at the top and \ct{run()} at the bottom.} or a version of Processing for microcontrollers such as Arduino. With this thesis, a limited version for a Smalltalk environment is also available.

Initially in the early 2010s, we ran our own IDE based on p5.js with custom error handling\footnote{This is still available from \url{https://software.zeniko.ch/ProcessingIDE.zip}. Note that it's targeted at \ct{mshta.exe} and as such runs best under Windows.} before changing to the official IDE for its Python mode.

Our experience of working with Processing over the past decade has shown that it allows novice programmers in the first year of high school to learn enough of the language within a month that they're able to write a clone of a game like ``Pong'', ``Flappy Bird'' or ``Geometry Dash'' as a group project. Feedback from the various student groups about this part of the computer science curriculum has always been positive to very positive. This aligns with what didactics states about student motivation (see \ref{sc_didactic}).



\section{Moldable Development} \label{sc_moldable}

``Moldable development'' is a term coined by Nierstrasz and Gîrba \cite{Gir22,Nie24} for a collection of development patterns which should make it easier to understand a computer system by extending (`molding') it with views and features. The goal of moldable development is to quickly get feedback on code and objects being worked on so that a programmer can confidently make appropriate changes.

In traditional IDEs, a running system is inspected either through its source code or its live runtime objects. Available views (see \ref{ssc_ides}) are static and new views are added through non-trivial extensions. Moldable development asks for an environment in which a tool is more easily adaptable to data, making it simple to write either one-off throw-away views and tools but also allowing to refactor such throw-away code into reusable components when needed.

Moldable development is thus a form of exploratory programming (cf. \ref{ssc_exploration}) on live objects where tools, whether one-off or reusable, are created in a bottom up approach with immediate feedback available at every step.

In order to support this, a moldable environment must have extensibility in its core, allowing to register tools and views e.\,g. through a simple code annotation of a few characters which the environment can use to detect and include it (instead of having to write a lot of configuration boilerplate and overhead which IDE extensions meant for independent distribution usually involve).

One core pattern of moldable development is the ``Moldable Object'': Objects should be implementable incrementally with live object states and previously developed views remaining available throughout the whole process. An object consisting of little more than a data wrapper is thus extended with new functionality as it fits the available live data -- instead of designing an object on a clean slate or along tests. Exploration code can then be extracted into tests, ensuring that what worked once will continue to work. Extending objects iteratively based on actual needs ensures that they remain transparent and that code is cleanly separated.

Having a moldable environment also allows for working on code and documentation intertwined, similar to literate programming \cite{Knu84}. Opposed to literate programming where code has to be extracted first, in moldable development every code snippet should be runnable on its own and beside code and documentation also live results can be included. This allows a moldable environment to be used to either first document ideas and then add matching code but also to document progress or explain written code (which can then easily be extracted into a test case).

For students, such a ``Project Diary'' pattern could be used as a learning journal (similar to Microsoft OneNote), for project exploration (similar to Jupyter notebooks) or for project documentation. Another useful pattern for teaching is the ``Composed Narrative'' which visualizes object relations through side-by-side views tailored towards explaining a relation or interaction.



\section{Glamorous Toolkit} \label{sc_gt}

``Glamorous Toolkit'' (GT) is a fully programmable environment optimized for moldable development (see \ref{sc_moldable}). It is programmed in Smalltalk and by default persists its entire state when shut down so that live objects don't have to be recreated at restart.

Historically, GT dates back to the 1990s and the Squeak virtual machine \cite{Ing97} which allowed for live code inspection, reflection and ease of customization. Squeak was among others created by the same minds that authored the Smalltalk language and was thus based on Smalltalk.


\begin{figure} \label{fig_gt_screenshot}
\centering
\includegraphics[height=3cm]{images/gt_screenshot}
\caption{GT with a live notebook page (left) and inspectable object view (right)}
\end{figure}

Brief introduction into GT for the uninitiated and reasons for using it. \cite{Gir23}

\begin{todo}
\item Origins of GT in Smalltalk, Squeak, Pharo
\item Easy to inspect, adapt, extend
\item Developed by feenk (nod to Oscar)
\item Base concepts: \ct{<gtView>}, \ct{<gtExample>}, ...
\item Currently tied to Smalltalk, with other languages such as Python, JavaScript, Java supported through bridges
\item Development happens mainly under MacOS, thus Windows integration lags behind (visible e.\,g. when using PythonBridge)
\end{todo}
