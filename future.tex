%%%%% Conclusion and Future Work %%%%%

\chapter{Conclusion} \label{ch_conclusion}

In order to better understand complex content -- at least with regards to computer science --, didactic literature recommends that students perform a \emph{Sichtenwechsel}, \ie observe the same entity at different abstraction levels, in order to better understand the subject at hand. As part of our teaching computer science to high school students, we've been particularly interested in being able to do so with regards to popular programming and less popular computer architecture.

While various programming \acp{IDE} provide some possibilities to get relevant insights into a computer's inner workings, none of them offer an all-in-one solution as a building block at a complexity level manageable for high school students. As part of this thesis, the new teaching environment ``Processing Abstractions'' has thus been introduced, implementing a compiler and runtime for the Processing language inside of \acf{GT}, which allows teachers to flexibly combine various forms of content in a unified environment. On the basis of the working Processing system, a wide variety of views of various aspects of it has been added, allowing students to inspect a program from source code to machine bytecode and through its execution.

This enabled the creation of interactive teaching material that engages students through its liveness and by allowing teachers to lead them at their own pace and depth through the material, having students explore and experience what steps computers have to take for transforming their idea of a program into something sufficiently concrete that can actually be executed in a (virtual) machine.

Working with students showed that the environment mostly worked and managed to get students involved. While students seem to have learned through their own investigation into lower abstraction levels, significant effects could not (yet) be measured. This was in large part due to both a small sample size and too brief an observation window.

Further usage and studies will be required for verifying our initial assumptions. This remains planned for the school years to come. Additionally, the foundational idea of abstraction levels has to be introduced alongside explicitly, if students should be able to get a better understanding of when abstractions might leak and how that could be relevant.



\section{Future Work} \label{sc_future}

Continuing this path further, there are multiple ways to proceed. On the one hand, there are several aspects still missing from the environment itself. On the other hand, the same concept of \emph{Sichtenwechsel} might be applicable in other domains as well. Finally, a larger study confirming that this kind of approach is empirically sound is required.

Within the environment itself, there are several kinds of views that we feel are still missing. In particular, at this point most views show a single state along abstraction deconstruction. Visualizations of how to get from one to the next are still missing and would have to happen mainly in students' minds for now. Even just animating the Runsteps view instead of students having to click through, with differences from one to the other step being highlighted, might help. More interesting would, however, be animating the process of parsing tokens into an \ac{AST} or more ambitiously the process of taking Processing source code, parsing it and then translating it.

Also, most lists provide access to native \ac{GT} objects, which have views not optimized for students. Instead of \eg giving direct access to a bytecode object, which only contains a pointer back to the Smalltalk source, these could be wrapped or extended, so that their default view continues to be informative such as showing a short explanation of what the selected command does.

Then the machine code shown to students is for a stack machine. Common microprocessors, such as those of the x64 architecture at the heart of our students' computers, are, however, register based. Compiling code to a matching machine language by \eg transpiling it to C and then having it compiled to x64 machine code would be a possible approach. Another approach would consist in directly translating it to Intel Assembly or corresponding bytecode. In order to then run such code, a matching virtual machine or a better way to show intermediary processor states would be required, if the execution steps are again to be observed.

Two other steps that are missing for inspecting the process of compilation are type inference and optimizations. Processing and Smalltalk are both dynamically typed languages, which circumvents type checking considerations during the compilation to bytecode, as type differences are handled through inheritance and only optimized by a \ac{JIT}. Exposing type information and visualizing a type inference algorithm such as Hindley-Milner could be added. Python's syntax would even allow type hints, which could also be used to allow students to experiment with types.

Optimization on the other hand happens at various abstraction levels. With regards to choosing the right algorithm for a problem, a program's runtime behavior could be timed and shown. Alternatively, most programs written by high schoolers should be understandable and analyzable by current \acp{LLM}, so that adding a \ac{LLM}-enabled view could give students feedback at the highest level. At lower levels, \ac{GT} offers a \ct{GtMethodAdvice} system for analyzing source code at the method or expression level, which could be exposed and/or expanded. Similarly, \ac{GT}'s \ac{IR} could be optimized further than \ct{IrMethod>>optimize} does and its optimizations transformations exposed to students.

As for the implementation of Processing, many bits are missing. Mainly support for object-oriented programming should be achievable, since Python's object model should again map sufficiently well onto Smalltalk's. What will, however, not be realistically possible is to get a sufficiently full Python inside \ac{GT}, which would allow importing (arbitrary) further modules. This should, however, not be as much of an issue, since similar to the Processing \ac{IDE}, hitting the limitations of the environment should be taken as a hint that the environment has been outgrown and to move to more capable tools, continuing the investigations using professional debuggers, memory viewers, \etc

For students coming from a different programming language, adapting the environment to their language of choice might also be doable. Since \ac{GT} already contains support for parsing dozens of languages (among other languages JavaScript, C(++), Rust or even Visual Basic), matching a subset of that language from its \ac{AST} to Smalltalk should be doable in the same way as \ct{ProcessingTranspiler} was implemented. At least when sticking to the Processing \ac{API}, the rest of the environment could be reused with minimal adjustments.

Going beyond programming, the same principle might also be applicable to other domains: We have already seen the Filius environment, which allows students to deconstruct networks to various depths. In natural sciences, processes can be investigated and deconstructed in a similar fashion in a simulated environment. Based on a framework like NetLogo,\footnote{\emph{Cf.} \eg \url{https://www.netlogoweb.org/launch\#http://www.netlogoweb.org/assets/modelslib/Sample\%20Models/Biology/Ants.nlogo}.} which already presents multiple views of the same phenomenon, further views for deconstructing and understanding the observed behavior could be added. Having the simulation inside a moldable environment would certainly help.

In the same vein, in a psychology course, students could be exposed to views of the subconscious, neurology down to biology and maybe even physics, when discussing behavior -- for a better understanding of the various influences on what might be perceived as purely mental; or in a music class, students could get harmonics decomposed into oscillation and ratios -- for a better understanding of what causes harmony; \etc Applying this principle in other domains is, however, left to specialists of those. What is nonetheless desired in all cases is an interdisciplinary approach, once lower abstraction levels go beyond one's own domain.\footnote{Similarly, how chemistry and physics will have to be involved when discussing the innards of a modern microprocessor.}

However first, we have to proceed with a further investigation into whether our students from different classes are indeed profiting in the way we intended them to.
