%%MAIN: thesis.tex

%%%%% The Problem %%%%%
%%%%% Related Work %%%%%
\chapter{Leaky Abstractions when Teaching Programming} \label{ch_theory}
% On the lack of connecting high-level languages with lower-level concepts

Before introducing the product of this thesis in chapter \ref{ch_pa}, we first introduce the problem it should help solve: How abstractions involved in programming are taught.

In detail, we first introduce the concept of (leaky) abstractions in multitier architectures in section \ref{sc_abstractions}; show how these are discussed in didactic literature in sections \ref{sc_didactic}; and how common IDEs already support handling these difficulties (in section \ref{sc_ides}).


\section{Multitier Architectures and (Leaky) Abstractions} \label{sc_abstractions}
In order to handle complexities arising in both theoretical and practical computer science, subjects are split into multiple layers or tiers to be described, investigated and used separatedly. \xxx{citation needed?}

Common such multitier architectures taught at high school level are the networking stack (either the seven layered OSI model or the simplified four layered DoD architecture) or the software-hardware stack ranging from apps and hardware abstracting OS down to transistors consisting of e.\,g. silicium atoms.

\xxx{diagram of such an architecture?}

Ideally, in such architectures all layers above the layer to be investigated can be ignored (beyond what the layer will be used for) and all the layers below can be abstracted away into a nicely defined interface.

As such, programming should be possible to be done independently of hardware and even the operating system, in the same way that natural languages can be taught independently of body or mind of the students.

In his article ''The Law of Leaky Abstractions'' \citep{Spo02} introduces the concept of \emph{leaky abstractions}, claiming that for all non-trivial such architectures, details of lower layers are to some degree bound to bleed through to upper layers. In other words, in practice complex interfaces tend to be incomplete or 'leaky'.

In teaching computer science, such leaky abstractions occur repeatedly, e.\,g. when an app doesn't run on a different device (with either the OS or the processor architecture leaking); or when a document seemingly can't be saved (with either the file system or differences between apps leaking).

More specifically, in programming there are several ways of abstracting away technical details:

\begin{itemize}
\item Programming instructions consist of source code which consists of encoded bits which are stored in memory or on a drive.
\item Source code consists of tokens which are usually parsed into an abstract syntax tree (AST) which are either directly or via intermediary representations translated into machine code to be run on a virtual or actual machine.
\item When programming instructions through the above abstractions are executed, variable values are encoded and stored in memory, function calls are tracked through a call stack, input state is continually mapped into memory and output is generated in several forms -- where e.g. textual output causes a font renderer to interpret glyph instructions for every character; or graphical output is anti-aliased before any pixel data is produced.
\end{itemize}
\xxx{citation needed?}

Of these different layers, students usually focus on turining instructions into source code and then checking the program's output -- or any error messages produced by the compiler or interpreter (see section \ref{sc_didactic}). Still, several of the lower layered abstractions might leak through, such as:

\begin{itemize}
\item Missing a stop condition in a recursive function leads to a cryptic ''Stack overflow'' error -- leaking information about the call stack.
\item If a program outputs emojis, they might look notably differently in source code and output -- leaking font rendering.
\item Similarly, programs containing emojis might have emojis garbled depending on the app used for inspecting the source code -- leaking text encoding.
\item If a program contains an endless loop, there might be neither error message nor output, so that it might wrongly seem that the computer isn't doing anything. This isn't an abstraction leak in the above sense but a related student misconception.
\end{itemize}


\section{Didactic Approaches} \label{sc_didactic}
See e.\,g. \cite{Sch11}, \cite{Mod16}, \cite{Har20} or \cite{Lee20} only focusing on one aspect

\subsection{Teaching Top Down}
Working downwards from gaming, as in \cite{Wei16}

\subsection{Teaching Bottom Up}
Running Tetris on NANDs as described in \cite{Cak17}, \cite{Nis21}


\section{Abstractions in IDEs} \label{sc_ides}
% Brief overview over views offered by common IDEs (such as VS Code) but mainly didactic ones such as Thonny (\cite{Ann15}), Mu (\cite{Tol23}), \emph{etc.}.

Integrated development environments used for programming offer a variety of different views on a program beyond its source code and its runtime output. The popular Visual Studio Code offers e.\,g. through extensions step-by-step debugging with variables and the call stack listed \cite{Mic25}. This is mirrored in most other full fledged IDEs such as PyCharm \citep{Jet25} or Eclipse \citep{Ecl25}.

And while such IDEs through appropriate extensions even allow inspecting Python bytecode, the respective views are usually overwhelming for programming novices and thus rather targetted at professional developers than high school students.

As a remedy, several teaching oriented IDEs have been developped, such as ''Code with Mu'' which offers a minimal command set and still allows runtime inspection \citep{Tol23}; or Thonny which had the goal to visualize runtime concepts beyond what IDEs offered at the time \citep[p. 119]{Ann15}:

On the one hand, Thonny shows intermediary steps during expression evaluation. This demonstrates that statements are not evaluated in one go, but indeed in a predetermined order operation by operation.\footnote{In professional IDEs, intermediary results are usually available by hovering over a specific operator with the order of evaluation being left to the user to determine.}

On the other hand, Thonny visualizes recursion by showing code in a new pop-up for every function call, so that multiple recursive function calls lead to an equivalent number of visible pop-ups. Most other IDEs rather show a call stack as in a separate view, which abstracts the stack into a list.\footnote{As a compromise, Glamorous Toolkit presented in chapter \ref{ch_background} displays the call stack as a list of expandable method sources with the call location highlighted.}

Finally, Thonny distinguishes between values on the stack and on the heap, showing the pointer to the heap as the value actually pushed on the stack and in a separate view the actual object on the heap at the given address.

Thus, the Thonny IDE set out to and indeed nicely visualizes several concepts on lower runtime layers.

\cite{Jal22} has assembled a list of tools targetted at visualizing some of these concepts outside of an IDE. One noteable such alternative approach is taken by Python Tutor \citep{Pyt25} which combines a visualization of stack frames variable values as pointers and deconstructed objects.
