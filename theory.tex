%%MAIN: thesis.tex

%%%%% The Problem %%%%%
%%%%% Related Work %%%%%
\chapter{Leaky Abstractions when Teaching Programming} \label{ch_theory}
% On the lack of connecting high-level languages with lower-level concepts

Before introducing the product of this thesis in chapter \ref{ch_pa}, we first introduce the problem it should help solve: How abstractions involved in programming are taught.

In detail, we first introduce the concept of (leaky) abstractions in multitier architectures in section \ref{sc_abstractions}; show how these are discussed in didactic literature in sections \ref{sc_didactic}; and how common IDEs already support handling these difficulties (in section \ref{sc_ides}).


\section{Multitier Architectures and (Leaky) Abstractions} \label{sc_abstractions}
In order to handle complexities arising in both theoretical and practical computer science, subjects are split into multiple layers or tiers to be described, investigated and used separatedly. \xxx{citation needed?}

Common such multitier architectures taught at high school level are the networking stack (either the seven layered OSI model or the simplified four layered DoD architecture) or the software-hardware stack ranging from apps and hardware abstracting OS down to transistors consisting of e.\,g. silicium atoms.

\xxx{diagram of such an architecture?}

Ideally, in such architectures all layers above the layer to be investigated can be ignored (beyond what the layer will be used for) and all the layers below can be abstracted away into a nicely defined interface.

As such, programming should be possible to be done independently of hardware and even the operating system, in the same way that natural languages can be taught independently of body or mind of the students.

In his article ``The Law of Leaky Abstractions'' \citep{Spo02} introduces the concept of \emph{leaky abstractions}, claiming that for all non-trivial such architectures, details of lower layers are to some degree bound to bleed through to upper layers. In other words, in practice complex interfaces tend to be incomplete or 'leaky'.

In teaching computer science, such leaky abstractions occur repeatedly, e.\,g. when an app doesn't run on a different device (with either the OS or the processor architecture leaking); or when a document seemingly can't be saved (with either the file system or differences between apps leaking).

More specifically, in programming there are several ways of abstracting away technical details:

\begin{itemize}
\item Programming instructions consist of source code which consists of encoded bits which are stored in memory or on a drive.
\item Source code consists of tokens which are usually parsed into an abstract syntax tree (AST) which are either directly or via intermediary representations translated into machine code to be run on a virtual or actual machine.
\item When programming instructions through the above abstractions are executed, variable values are encoded and stored in memory, function calls are tracked through a call stack, input state is continually mapped into memory and output is generated in several forms -- where e.\,g. textual output causes a font renderer to interpret glyph instructions for every character; or graphical output is anti-aliased before any pixel data is produced.
\end{itemize}
\xxx{citation needed?}

Of these different layers, students usually focus on turining instructions into source code and then checking the program's output -- or any error messages produced by the compiler or interpreter (see section \ref{sc_didactic}). Still, several of the lower layered abstractions might leak through, such as:

\begin{itemize}
\item Missing a stop condition in a recursive function leads to a cryptic ``Stack overflow'' error -- leaking information about the call stack.
\item If a program outputs emojis, they might look notably differently in source code and output -- leaking font rendering.
\item Similarly, programs containing emojis might have emojis garbled depending on the app used for inspecting the source code -- leaking text encoding.
\item If a program contains an endless loop, there might be neither error message nor output, so that it might wrongly seem that the computer isn't doing anything. This isn't an abstraction leak in the above sense but a related student misconception.
\end{itemize}

Besides the above rather easily observable abstraction leaks, the issue might also have to be discussed itself, since one class of leaky abstractions has been shown to be security critical: timing attacks. Since programs might be compiled differently and optimized differently and run on different hardware, runtime timing is not considered to be inherent to a particular source code.\footnote{At least beyond generic complexity considerations on an algorithmic level.}

In cryptography, timing attacks have been successfully used for extracting passwords from insufficiently protected webservers \citep{Por18}. More recently, another class of timing attacks taking advantage of modern CPU's branch prediction optimizations has been demonstrated \citep{Koc19}. In the latter case, an implementation detail of the CPU managed to leak. And in both cases, at least implementors of cryptographic programs must be aware of lower abstraction layers.


\section{Didactic Approaches} \label{sc_didactic}
% See e.\,g. \cite{Sch11}, \cite{Mod16}, \cite{Har20} or \cite{Lee20} only focusing on one aspect
The abstractions encountered in programming as discussed in section \ref{sc_abstractions}, are not always handled in didactic literature.

Traditional introductions into programming focus on the language, its syntax and the available semantics. E.\,g. \cite{Har20} introduces most of Python so that it can later be used for scientific calculations. This traditional introduction omits many of the lower abstraction levels listed in the previous section. Interestingly, it does not assume an IDE (see section \ref{sc_ides} below), but instead very briefly introduces the command line and the Python REPL\footnote{REPL is short for \emph{Read-Evaluate-Print-Loop} i.\,e. an interactive interpreter.}. Even though in that way, files are not guaranteed to be UTF-8 encoded (as examples assume, cf. p.\,118), encodings are not mentioned beyond pure ASCII (p.\,115). And the Python interpreter is just in the preface briefly characterized as ``program which translates source code into electronic instructions''\footnote{German original: ''[...] das Programm, das den Programmcode in Elektronik-Anweisungen übersetzt.''}.

In the context of most introductions to programming, that might be sufficient with relation to available time and goal of the course. In broader teaching context such as high school CS courses, didactic teachers ask for more. \cite{Sch11} proposes an introduction into programming to use several different programming languages along different paradigma: e.\,g. Prolog as a declarative language (pp.\,91--104) and Python as object oriented language (pp.\,157--185), in order to demonstrate to students already at the level of instructions that the language chosen comes with inherent limitations in expressibility (p.\,154, comparing programming languages with natural languages and referring to Wittgenstein's philosophy of language).

\subsection{\emph{Sichtenwechsel}} \label{sichtenwechsel}
Furthermore in a broader context, they propose to explicitly discuss multitier architectures -- and that not only in the context of the networking stack and computer archictecture (pp.\,113--116):

They introduce the notion of \emph{Sichtenwechsel}, a change of perspective with relation to the current layer, which should help students better understand concepts of one layer by inspecting lower layers. As an example, the show a live model of a calculator app whose input is translated to both pseudo code and machine code (p.\,115); an environment for inspecting live Java objects (pp.\,208--209); or the Filius environment for inspecting a virtual computer network at its different layers (p.\,284).

They conclude that ``it was a fallacy to assume that students would be able to develop a working model of a computer [...] by designing small programs'' (p.\,213),\footnote{German original: ''Es erwies sich als Irrtum, dass Schüler beim Entwerfen kleiner Programme ein tragfähiges kognitives Modell vom Rechner oder von Informatiksystemen im Allgemeinen entwickeln.''} reinforcing the need for going beyond of what traditional programming courses (used to) do.


\subsection{Teaching Bottom Up} \label{ssc_bottom_up}
Running Tetris on NANDs as described in \cite{Cak17}, \cite{Nis21}; basing every layer on the layers below

\subsection{Teaching Top Down} \label{ssc_top_down}
Working downwards from gaming, as in \cite{Wei16}, or art as in \cite{Cas14}; starting at motivating examples and then extending unterstanding and capabilites

\subsection{Exploratory and Live Programming} \label{ssc_exploration}
Letting students explore concepts on their own -- with live feedback from the environment


\section{Abstractions in IDEs} \label{sc_ides}
% Brief overview over views offered by common IDEs (such as VS Code) but mainly didactic ones such as Thonny (\cite{Ann15}), Mu (\cite{Tol23}), \emph{etc.}.

Integrated development environments used for programming offer a variety of different views on a program beyond its source code and its runtime output. The popular Visual Studio Code offers e.\,g. through extensions step-by-step debugging with variables and the call stack listed \cite{Mic25}. This is mirrored in most other full fledged IDEs such as PyCharm \citep{Jet25} or Eclipse \citep{Ecl25}.

And while such IDEs through appropriate extensions even allow inspecting Python bytecode, the respective views are usually overwhelming for programming novices and thus rather targetted at professional developers than high school students.

As a remedy, several teaching oriented IDEs have been developped, such as ``Code with Mu'' which offers a minimal command set and still allows runtime inspection \citep{Tol23}; or Thonny which had the goal to visualize runtime concepts beyond what IDEs offered at the time \citep[p.\,119]{Ann15}:

On the one hand, Thonny shows intermediary steps during expression evaluation. This demonstrates that statements are not evaluated in one go, but indeed in a predetermined order operation by operation.\footnote{In professional IDEs, intermediary results are usually available by hovering over a specific operator with the order of evaluation being left to the user to determine.}

On the other hand, Thonny visualizes recursion by showing code in a new pop-up for every function call, so that multiple recursive function calls lead to an equivalent number of visible pop-ups. Most other IDEs rather show a call stack as in a separate view, which abstracts the stack into a list.\footnote{As a compromise, Glamorous Toolkit presented in chapter \ref{ch_background} displays the call stack as a list of expandable method sources with the call location highlighted.}

Finally, Thonny distinguishes between values on the stack and on the heap, showing the pointer to the heap as the value actually pushed on the stack and in a separate view the actual object on the heap at the given address.

Thus, the Thonny IDE set out to and indeed nicely visualizes several concepts on lower runtime layers.

\cite{Jal22} has assembled a list of tools targetted at visualizing some of these concepts outside of an IDE. One noteable such alternative approach is taken by Python Tutor \citep{Pyt25} which combines a visualization of stack frames variable values as pointers and deconstructed objects.
