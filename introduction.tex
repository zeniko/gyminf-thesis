%%%%% Introduction %%%%%

\chapter{Introduction}

In our modern digitized society, the importance of computer science has grown to the point where some of its subjects are taught at schools of all levels. Whereas elementary schools focus on introducing digital, connected devices and their applications, high schools also teach fundamentals, and while programming or application use courses have been implemented for decades, broader and more theoretical courses have only recently become standard. \eg in Switzerland, in 2019 computer science became an obligatory subject for all high school students, similar to more traditional sciences.

The curricula used at high schools usually contain introductions not only to algorithms and programming but among other topics also to encodings, computer architecture, networking, and social ramifications such as privacy and security (see \eg \cite{Erz16}). Students are therefore not only taught a high-level programming language such as Python but should also develop insights into what happens at various other abstraction levels when such a program is stored and run.

One traditional approach to teaching computer architecture consists in teaching a separate assembly-like language during the introduction to computer architecture. This can happen in a more gamified fashion \eg with the app Human Resource Machine \cite{Tom15}, closer to theory with the Von Neumann Simulator \cite{Gan23} or even without mnemonics using the Little Man Computer architecture \cite{Oin25}. While all of these approaches help to show how a microprocessor might work approximately, none of them offer a direct, explorable connection to a high-level language.

In our experience, high-level programming has been quite well received with students, whereas the teaching sequence on computer architecture was less so. Programming and computer architecture also hadn't fit together as nicely as we would have liked, and processor and memory have remained a mystery for too many students.

We claim that joining the computer architecture sequences to the programming one by revealing and discussing abstraction levels involved in executing a program on a (virtual) machine will improve students' understanding of computer architecture (as well as programming). For this thesis we thus set out to create an environment and course materials for testing this claim.

In this thesis, we thus present the teaching environment ``Processing Abstractions'' (introduced in chapter \ref{ch_pa}) for experiencing and discussing abstractions encountered during programming (see \eg figure \ref{fig_screenshot_vm_execution} on page \pageref{fig_screenshot_vm_execution}), allowing students to have a \emph{Sichtenwechsel} on their own programs (\ie a change of perspective with relation to layers involved, a concept introduced in \ref{sc_sichtenwechsel}) and allowing teachers to discuss abstractions in a palpable setting.

This Processing Abstractions environment connects the high-level language Processing (based on Python and introduced in section \ref{sc_processing}) with various layers down to bytecode for the Glamorous Toolkit platform (introduced in section \ref{sc_gt}), and is targeted at high school students.

We deem such a teaching environment as being called for, if didactic literature (summarized in \ref{sc_didactic}) and currently existing \acp{IDE} are considered. In particular, we propose to use this as a basis for explicitly discussing the foundational idea of multitier abstractions with students, which appear in multiple places throughout their curriculum within computer science -- most prominently in networking and information encoding -- but also other subjects such as natural sciences, psychology, \etc This discussion is important insofar as the clean separation of abstraction levels may unexpectedly fail or ``leak'' (a concept introduced in \ref{ssc_leaky_abstractions}), exposing lower levels through seemingly irrelevant side effects such as timing or physical constraints.

For teachers, suggestions for how to include the environment in the classroom are provided in chapter \ref{ch_teaching}, with a sequence on computer architecture at the center, but flanked by two sequences on programming and compilers for embedding it. All these sequences build upon the teaching environment provided and rely on students being able to get multiple, varied views and insights into the same program, in order to experience the behind-the-scenes work or rather the details usually abstracted away in an interactive way. The students' engagement is ensured due to all input being readily modifiable with changes being immediately visible, allowing for almost frictionless exploration.

Parts of the lessons suggested have already been tested with two classes at Gymnasium Neufeld in Berne for collecting valuable feedback from students. While the sample size was too small to get statistically significant results, observations and student feedback (discussed in chapter \ref{ch_practice}) have shown that the environment works and that students are motivated by its liveness to explore the concepts provided. Whether their understanding of the abstraction levels involved have improved, could, however, unfortunately not (yet) be shown.

All of this wouldn't have been possible without the very helpful support of Prof.\,em. Oscar Nierstrasz who has finally managed to introduce me to Smalltalk and Prof. Timo Kehrer who has taken this project together with his predecessor under his wing. I also want to thank my students from the classes 27Ga and 28Ga of Gymnasium Neufeld who have worked with my prototype and given helpful feedback. Finally, many thanks go to my kids for their understanding of me having to work even during their holidays and to my wife for her endless support, which made this thesis possible in the first place.
