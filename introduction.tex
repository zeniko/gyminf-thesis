%%%%% Introduction %%%%%

\chapter{Introduction}

In our modern digitized society, the importance of computer science has grown to the point where some of its subjects are taught at schools of all levels. Whereas elementary schools focus on introducing digital, connected devices and their applications, high schools also teach fundamentals, and while programming or application use courses have been implemented for decades, broader and more theoretical courses have only recently become standard. In Switzerland \eg computer science became an obligatory subject for all high school students in 2019, similar to more traditional sciences.

The curricula used in high schools usually contain introductions not only to algorithms and programming but, among other topics, also to encodings, computer architecture, networking, and social ramifications such as privacy and security (see \eg \cite{Erz16}). Students are therefore not only taught a high-level programming language such as Python but should also develop insights into what happens at various other abstraction levels when such a program is stored and run.

One traditional approach to teaching computer architecture consists in teaching a separate assembly-like language during the introduction to computer architecture. This can happen in a more gamified fashion, \eg with the app Human Resource Machine \cite{Tom15}, closer to theory with the Von Neumann Simulator \cite{Gan23}, or even without mnemonics using the Little Man Computer architecture \cite{Oin25}. While all of these approaches help to show how a microprocessor might work approximately, none of them offer a direct, explorable connection to a high-level language.

In our experience, high-level programming is quite popular with students, whereas the teaching sequence on computer architecture tends to be less so. Programming and computer architecture also haven't fit together as nicely as we would have liked, and processor and memory have remained a mystery for too many students.

Multitier architectures are considered to be a foundational idea of computer science by didactic literature (summarized in \ref{sc_didactic}), which is to be explicitly discussed with students. Such architectures appear in multiple places throughout their curriculum within computer science -- most prominently also in networking and information encoding -- but also in other subjects such as natural sciences, psychology, \etc This discussion is important insofar as the clean separation of abstraction levels may unexpectedly fail or ``leak'' (a concept introduced in \ref{ssc_leaky_abstractions}), exposing lower levels through seemingly irrelevant side effects such as timing or physical constraints. For a better understanding of such multitier architectures, a \emph{Sichtenwechsel} (\ie a change of perspective in relation to layers involved, a concept introduced in \ref{ssc_sichtenwechsel}) is called for.

Following this, we claim that joining the teaching sequences for computer architecture sequences and programming, by revealing and discussing abstraction levels involved in executing a program on a (virtual) machine, will improve students' understanding of both computer architecture and programming. For this thesis, we thus set out to create an environment and course materials to test this claim.

In this thesis, we present the teaching environment ``Processing Abstractions'' (introduced in chapter \ref{ch_pa}) to experience and discuss abstractions encountered during programming (see \eg figure \ref{fig_screenshot_vm_execution} on page \pageref{fig_screenshot_vm_execution}), allowing students to have a \emph{Sichtenwechsel} on their own programs and allowing teachers to discuss abstractions in a palpable setting.

The Processing Abstractions environment connects the high-level language Processing (based on Python and introduced in section \ref{sc_processing}) with various layers down to bytecode for the Glamorous Toolkit platform (introduced in section \ref{sc_gt}), and is targeted at high school students.

For teachers, suggestions for how to include the environment in the classroom are provided in chapter \ref{ch_teaching}, with a sequence on computer architecture at the center, but flanked by two sequences on programming and compilers for embedding it. All these sequences build upon the teaching environment provided and rely on students being able to get multiple, varied views and insights into the same program, in order to experience the behind-the-scenes work, or rather the details usually abstracted away, in an interactive way. The students' engagement is ensured due to all input being readily modifiable with changes being immediately visible, allowing for almost frictionless exploration.

Parts of the lessons suggested have already been tested with two classes at Gymnasium Neufeld in Berne to collect valuable feedback from students. While the sample size was too small to get statistically significant results, observations and student feedback (discussed in chapter \ref{ch_practice}) have shown that the environment works and that students are motivated by its liveness to explore the concepts provided. Whether their understanding of the abstraction levels involved has improved, could, unfortunately, not (yet) be shown.

All of this wouldn't have been possible without the very helpful support of Prof.\,em. Oscar Nierstrasz, who has finally managed to introduce me to Smalltalk, as he did with my former classmates twenty years ago, and Prof. Timo Kehrer, who has taken this project under his wing together with his predecessor. I also want to thank my students from the classes 27Ga and 28Ga of Gymnasium Neufeld, who have worked with my prototype and given helpful feedback. Finally, many thanks go to my kids for their understanding of me having to work even during their holidays, and to my wife for her endless support, which made this thesis possible in the first place.
